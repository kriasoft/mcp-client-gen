/**
 * Generated MCP client for Notion API.
 *
 * Usage:
 * ```ts
 * const client = new NotionClient({
 *   url: process.env.NOTION_MCP_URL,
 *   headers: { Authorization: `Bearer ${token}` }
 * });
 * const page = await client.fetch({ id: pageId });
 * ```
 *
 * @generated by mcp-client-gen
 * @see https://modelcontextprotocol.io for MCP protocol details
 *
 * SPDX-FileCopyrightText: 2025-present Kriasoft
 * SPDX-License-Identifier: MIT
 */

import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import type { StreamableHTTPClientTransportOptions } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";

export interface FetchInput {
  id: string;
  [key: string]: unknown; // Required: MCP protocol expects Record<string, unknown>
}

export interface FetchOutput {
  [key: string]: unknown; // Extend with specific fields per Notion's schema
}

interface NotionClientOptions extends StreamableHTTPClientTransportOptions {
  /**
   * MCP server URL.
   * @default "https://mcp.notion.com/mcp"
   * @security In production, use environment variables or secure config.
   * Never hardcode sensitive URLs or credentials.
   */
  url?: URL | string;
  client?: {
    name?: string;
    version?: string;
    title?: string;
  };
}

/**
 * Extracts first content item from MCP tool result, validating structure.
 *
 * @param result - Raw MCP tool response with content[] and optional isError flag
 * @param toolName - Tool identifier for error context
 * @returns First content object, type-cast to T
 * @throws {Error} When isError=true, content missing/empty, or content[0] not object
 */
function handleToolResult<T = any>(result: any, toolName: string): T {
  // MCP spec: tools report errors via isError flag, not protocol errors
  if (result.isError) {
    const errorContent = result.content?.[0];
    const errorMessage =
      errorContent && typeof errorContent === "object" && "text" in errorContent
        ? String(errorContent.text)
        : "Tool execution failed";
    throw new Error(`${toolName} error: ${errorMessage}`);
  }

  // MCP always returns content array, even for single values
  if (
    !result.content ||
    !Array.isArray(result.content) ||
    result.content.length === 0
  ) {
    throw new Error(`${toolName} returned empty content`);
  }

  // Content items must be objects (text/image/resource blocks)
  const content = result.content[0];
  if (!content || typeof content !== "object") {
    throw new Error(`${toolName} returned invalid content structure`);
  }

  return content as T;
}

/**
 * Extracts first content item from MCP resource result, validating structure.
 *
 * @param result - Raw MCP resource response with contents[]
 * @param resourceUri - Resource URI for error context
 * @returns First content object, type-cast to T
 * @throws {Error} When contents missing/empty
 */
function handleResourceResult<T = any>(result: any, resourceUri: string): T {
  // MCP resources return contents array (not content)
  if (
    !result.contents ||
    !Array.isArray(result.contents) ||
    result.contents.length === 0
  ) {
    throw new Error(`Resource '${resourceUri}' returned empty contents`);
  }

  return result.contents[0] as T;
}

export class NotionClient {
  private readonly client: Client;
  private readonly transport: StreamableHTTPClientTransport;
  private connecting: Promise<void> | null = null;
  private connected = false;

  constructor(options: NotionClientOptions = {}) {
    const { client = {}, url, ...other } = options;
    this.client = new Client({
      name: client.name ?? "notion",
      version: client.version ?? "1.0.0",
      title: client.title ?? "Notion MCP",
    });

    this.transport = new StreamableHTTPClientTransport(
      new URL(url ?? "https://mcp.notion.com/mcp"),
      other,
    );
  }

  /**
   * Ensures single connection attempt, reusing in-flight promise if called concurrently.
   * @throws Connection errors are propagated, subsequent calls retry
   */
  private async ensureConnected() {
    if (this.connected) {
      return;
    }

    if (this.connecting) {
      await this.connecting;
      return;
    }

    this.connecting = this.client.connect(this.transport);
    try {
      await this.connecting;
      this.connected = true;
    } catch (error) {
      this.connecting = null; // Allow retry on next call
      throw error;
    }
  }

  async fetch<T extends FetchOutput>(input: FetchInput): Promise<T> {
    await this.ensureConnected();

    try {
      const result = await this.client.callTool({
        name: "fetch",
        arguments: input,
      });

      return handleToolResult<T>(result, "Notion fetch");
    } catch (error) {
      // Wrap non-Notion errors for context (network, MCP protocol, etc.)
      if (error instanceof Error && !error.message.startsWith("Notion fetch")) {
        throw new Error(`Failed to fetch from Notion: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Reads a resource from the MCP server.
   * Resources provide access to server capabilities like markdown specs.
   *
   * @param uri - Resource URI to read (e.g., "notion://markdown-spec")
   * @returns Resource content, structure varies by resource type
   */
  async getResource<T = any>(uri: string): Promise<T> {
    await this.ensureConnected();

    try {
      const result = await this.client.readResource({ uri });
      return handleResourceResult<T>(result, uri);
    } catch (error) {
      // Wrap non-resource errors for context
      if (error instanceof Error && !error.message.includes("Resource")) {
        throw new Error(`Failed to read resource '${uri}': ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Disconnects from the MCP server, closing both client and transport.
   * Safe to call multiple times - subsequent calls are no-ops.
   * Automatically called by Symbol.asyncDispose for `await using` support.
   */
  async disconnect() {
    if (this.connected || this.connecting) {
      try {
        await this.connecting;
        await this.client.close();
        await this.transport.close();
      } finally {
        this.connected = false;
        this.connecting = null;
      }
    }
  }

  async [Symbol.asyncDispose](): Promise<void> {
    await this.disconnect();
  }
}
